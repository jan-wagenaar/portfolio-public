{"componentChunkName":"component---src-pages-blog-strapi-post-slug-js","path":"/blog/optimizing-out-systems-timers-according-best-practices/","result":{"data":{"strapiPost":{"title":"Optimizing OutSystems Timers according Best Practices","createdAt":"2023-08-06T19:58:46.120Z","fomattedCreatedAt":"06-08-2023","cover":{"alternativeText":null,"url":"https://res.cloudinary.com/dqwogyxqp/image/upload/v1691351603/outsystems_timer_best_practices_cover_e2af488398.png","localFile":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#181818","images":{"fallback":{"src":"/static/e4242b1cea3af04de068a2033cf5c584/316cf/outsystems_timer_best_practices_cover_e2af488398.png","srcSet":"/static/e4242b1cea3af04de068a2033cf5c584/ee4bc/outsystems_timer_best_practices_cover_e2af488398.png 1423w,\n/static/e4242b1cea3af04de068a2033cf5c584/ce255/outsystems_timer_best_practices_cover_e2af488398.png 2846w,\n/static/e4242b1cea3af04de068a2033cf5c584/316cf/outsystems_timer_best_practices_cover_e2af488398.png 5692w","sizes":"(min-width: 5692px) 5692px, 100vw"},"sources":[{"srcSet":"/static/e4242b1cea3af04de068a2033cf5c584/687f8/outsystems_timer_best_practices_cover_e2af488398.webp 1423w,\n/static/e4242b1cea3af04de068a2033cf5c584/5a9cd/outsystems_timer_best_practices_cover_e2af488398.webp 2846w,\n/static/e4242b1cea3af04de068a2033cf5c584/f31bf/outsystems_timer_best_practices_cover_e2af488398.webp 5692w","type":"image/webp","sizes":"(min-width: 5692px) 5692px, 100vw"}]},"width":5692,"height":2847}}}},"content":{"data":{"childMarkdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Timers in OutSystems are a powerful tool for triggering actions and processes on a specific schedule. As a developer, you'll frequently encounter them in your applications. However, what distinguishes a great timer from the rest? Let's explore some best practices to ensure efficient and reliable timer usage."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Consider Using Processes"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"While timers are commonly used for batch processing due to their simplicity, consider leveraging processes for asynchronous processing. Processes are designed to run logic concurrently, making them ideal for large-scale batch processing. Light Processes in particular, which can run up to 20 threads simultaneously. In contrast to timers, which are limited to 3. My rule of thumb is: use processes for record processing and timers for logic that needs to adhere to a schedule."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Prevent Timeouts"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Timers have a standard timeout of 20 minutes, which can be adjusted, but it's best not to extend it significantly. Endless-running timers can clog up your timer schedule. Implement a timeout prevention mechanism to avoid losing work in progress:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"1. Create a local variable named \"TimeOut\" with the data type \"Date Time.\""}]},{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"src":"https://res.cloudinary.com/dqwogyxqp/image/upload/v1691351668/timeout_mechanism_1_set_variable_9bd48993d4.png","alt":"timeout mechanism 1 - set variable.png"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"2. Assign the variable with \"AddMinutes(CurrDate(), 15)\" to leave some error margin to the default timeout."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"3. With each record processed, check if the timer is still below its timeout by evaluating \"CurrDateTime() < Timeout.\""}]},{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"src":"https://res.cloudinary.com/dqwogyxqp/image/upload/v1691351700/timeout_mechanism_2_rewake_timer_7a7db6915b.png","alt":"timeout mechanism 2 - rewake timer.png"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Avoid Repeating Work"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Efficiency is compromised when a timer re-processes items. Prevent this by keeping track of completed items. You can achieve this by using attributes like \"IsProcessed\" or \"FinishedAt\" depending on the context of your processing. Alternatively, consider using a log entity to track completed items. Also, ensure that external systems do not modify data while the timer is running to prevent potential bugs."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Ensure Completeness"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Every timer must eventually come to an end. Be cautious not to create ever-running timers, especially now that you've implemented a timeout prevention mechanism. Validate your query when retrieving items to process, and ensure that completed items are tracked accordingly. Additionally, consider implementing a \"KillSwitch\" site property to abort timers that run indefinitely, thereby avoiding potential headaches."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"src":"https://res.cloudinary.com/dqwogyxqp/image/upload/v1691351778/ensure_completeness_1_kill_switch_f2f8cd06dc.png","alt":"ensure completeness 1 - kill switch.png"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Ensure Data Integrity"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Errors should not disrupt your timer logic. Expect the unexpected and build proper error handling into your logic. To facilitate error management, extract your record processing logic into a separate action. Introduce an \"Exception Handler\" node to catch any errors that may occur. If you set the \"Abort Transaction\" property of this handler to False, the timer will continue to the next record, ensuring that a single error doesn't block the entire processing stack."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"src":"https://res.cloudinary.com/dqwogyxqp/image/upload/v1691351822/data_integrite_1_error_handling_b61e027c0a.png","alt":"data integrite 1 - error handling.png"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Also, consider using \"CommitTransaction\" to commit changes to the database after processing a sensible set of records (e.g., after every 100 records)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"src":"https://res.cloudinary.com/dqwogyxqp/image/upload/v1691351845/data_integrity_2_commit_work_95af6060df.png","alt":"data integrity 2 - commit work.png"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now we've considered these best practices, here the gist of the whole flow:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"src":"https://res.cloudinary.com/dqwogyxqp/image/upload/v1691351896/timer_flow_15182f50ac.png","alt":"timer flow.png"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Hybrid Timer"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To leverage the best of both worlds---timers and processes---you can explore a hybrid timer approach. Use the timer solely to schedule records that need processing. After retrieving the list of data, trigger a batch of processes either through \"LaunchProcess\" or by creating queue records. Allow the process logic to handle the rest, enabling you to run logic on a specific schedule while benefiting from the concurrency offered by processes."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"src":"https://res.cloudinary.com/dqwogyxqp/image/upload/v1691351921/hybrid_timer_20360289f4.png","alt":"hybrid timer.png"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"By incorporating these best practices, you'll be able to harness the full potential of OutSystems timers while ensuring optimal performance and reliability in your applications. Happy coding!"}]}],"data":{"quirksMode":false}}},"content":"**Timers in OutSystems are a powerful tool for triggering actions and processes on a specific schedule. As a developer, you\\'ll frequently encounter them in your applications. However, what distinguishes a great timer from the rest? Let\\'s explore some best practices to ensure efficient and reliable timer usage.**\n\n### Consider Using Processes\nWhile timers are commonly used for batch processing due to their simplicity, consider leveraging processes for asynchronous processing. Processes are designed to run logic concurrently, making them ideal for large-scale batch processing. Light Processes in particular, which can run up to 20 threads simultaneously. In contrast to timers, which are limited to 3. My rule of thumb is: use processes for record processing and timers for logic that needs to adhere to a schedule.\n\n### Prevent Timeouts\nTimers have a standard timeout of 20 minutes, which can be adjusted, but it\\'s best not to extend it significantly. Endless-running timers can clog up your timer schedule. Implement a timeout prevention mechanism to avoid losing work in progress:\n\n1\\. Create a local variable named \\\"TimeOut\\\" with the data type \\\"Date Time.\\\"\n\n![timeout mechanism 1 - set variable.png](https://res.cloudinary.com/dqwogyxqp/image/upload/v1691351668/timeout_mechanism_1_set_variable_9bd48993d4.png)\n\n2\\. Assign the variable with \\\"AddMinutes(CurrDate(), 15)\\\" to leave some error margin to the default timeout.\n\n3\\. With each record processed, check if the timer is still below its timeout by evaluating \\\"CurrDateTime() \\< Timeout.\\\"\n\n![timeout mechanism 2 - rewake timer.png](https://res.cloudinary.com/dqwogyxqp/image/upload/v1691351700/timeout_mechanism_2_rewake_timer_7a7db6915b.png)\n\n### Avoid Repeating Work\nEfficiency is compromised when a timer re-processes items. Prevent this by keeping track of completed items. You can achieve this by using attributes like \\\"IsProcessed\\\" or \\\"FinishedAt\\\" depending on the context of your processing. Alternatively, consider using a log entity to track completed items. Also, ensure that external systems do not modify data while the timer is running to prevent potential bugs.\n\n#### Ensure Completeness\nEvery timer must eventually come to an end. Be cautious not to create ever-running timers, especially now that you\\'ve implemented a timeout prevention mechanism. Validate your query when retrieving items to process, and ensure that completed items are tracked accordingly. Additionally, consider implementing a \\\"KillSwitch\\\" site property to abort timers that run indefinitely, thereby avoiding potential headaches.\n\n![ensure completeness 1 - kill switch.png](https://res.cloudinary.com/dqwogyxqp/image/upload/v1691351778/ensure_completeness_1_kill_switch_f2f8cd06dc.png)\n\n#### Ensure Data Integrity\nErrors should not disrupt your timer logic. Expect the unexpected and build proper error handling into your logic. To facilitate error management, extract your record processing logic into a separate action. Introduce an \\\"Exception Handler\\\" node to catch any errors that may occur. If you set the \\\"Abort Transaction\\\" property of this handler to False, the timer will continue to the next record, ensuring that a single error doesn\\'t block the entire processing stack. \n\n![data integrite 1 - error handling.png](https://res.cloudinary.com/dqwogyxqp/image/upload/v1691351822/data_integrite_1_error_handling_b61e027c0a.png)\n\nAlso, consider using \\\"CommitTransaction\\\" to commit changes to the database after processing a sensible set of records (e.g., after every 100 records).\n\n![data integrity 2 - commit work.png](https://res.cloudinary.com/dqwogyxqp/image/upload/v1691351845/data_integrity_2_commit_work_95af6060df.png)\n\nNow we've considered these best practices, here the gist of the whole flow:\n\n![timer flow.png](https://res.cloudinary.com/dqwogyxqp/image/upload/v1691351896/timer_flow_15182f50ac.png)\n\n#### Hybrid Timer\nTo leverage the best of both worlds---timers and processes---you can explore a hybrid timer approach. Use the timer solely to schedule records that need processing. After retrieving the list of data, trigger a batch of processes either through \\\"LaunchProcess\\\" or by creating queue records. Allow the process logic to handle the rest, enabling you to run logic on a specific schedule while benefiting from the concurrency offered by processes.\n\n![hybrid timer.png](https://res.cloudinary.com/dqwogyxqp/image/upload/v1691351921/hybrid_timer_20360289f4.png)\n\nBy incorporating these best practices, you\\'ll be able to harness the full potential of OutSystems timers while ensuring optimal performance and reliability in your applications. Happy coding!\n"}},"SEO":{"keywords":"OutSystems timers, Timer best practices, Timer optimization, Timer reliability, Prevent timeouts, Avoid repeating work, Data integrity, Hybrid timers, Process concurrency, Light Processes, Asynchronous processing, Batch processing, Error handling, Timer scheduling, Timer performance, OutSystems development tips, Timer implementation, Timed actions, Timeout prevention, Timer efficiency","metaDescription":"Master OutSystems timers: Optimize performance & reliability with essential tips. Prevent timeouts, avoid repeating work, & ensure data integrity.","metaTitle":"Optimizing OutSystems Timers according Best Practices"}}},"pageContext":{"id":"f96b662a-ebd5-5b36-ac39-970c9216f57d","slug":"optimizing-out-systems-timers-according-best-practices","__params":{"slug":"optimizing-out-systems-timers-according-best-practices"}}},"staticQueryHashes":["1343364089","2159283857","2389677789","3769587215","4020630752","584364458"],"slicesMap":{}}