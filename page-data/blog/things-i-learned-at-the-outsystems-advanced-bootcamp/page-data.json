{"componentChunkName":"component---src-pages-blog-strapi-post-slug-js","path":"/blog/things-i-learned-at-the-outsystems-advanced-bootcamp/","result":{"data":{"strapiPost":{"title":"Things I learned at the Outsystems Advanced bootcamp","cover":{"alternativeText":null,"url":"https://res.cloudinary.com/dqwogyxqp/image/upload/v1672318913/cover_492a1363b7_7db9e4d317.png","localFile":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#181818","images":{"fallback":{"src":"/static/70531cef1e6a9567afd03532754c25d7/cc869/cover_492a1363b7_7db9e4d317.png","srcSet":"/static/70531cef1e6a9567afd03532754c25d7/5bd83/cover_492a1363b7_7db9e4d317.png 507w,\n/static/70531cef1e6a9567afd03532754c25d7/6670a/cover_492a1363b7_7db9e4d317.png 1013w,\n/static/70531cef1e6a9567afd03532754c25d7/cc869/cover_492a1363b7_7db9e4d317.png 2026w","sizes":"(min-width: 2026px) 2026px, 100vw"},"sources":[{"srcSet":"/static/70531cef1e6a9567afd03532754c25d7/bdb14/cover_492a1363b7_7db9e4d317.webp 507w,\n/static/70531cef1e6a9567afd03532754c25d7/603b5/cover_492a1363b7_7db9e4d317.webp 1013w,\n/static/70531cef1e6a9567afd03532754c25d7/f429a/cover_492a1363b7_7db9e4d317.webp 2026w","type":"image/webp","sizes":"(min-width: 2026px) 2026px, 100vw"}]},"width":2026,"height":727}}}},"content":{"data":{"childMarkdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"The Outsystems Advanced bootcamp is a deep dive in the entire Outsystems ecosystem. In the past week I attended it at "},{"type":"element","tagName":"a","properties":{"href":"https://www.transfer-solutions.com/"},"children":[{"type":"text","value":"Transfer Solutions"}]},{"type":"text","value":". It has been a great learning experience, ranging from small tips to best practices and more conceptual topics. I’m happy to share a few with you."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Avoid monolithic architectures"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A great deal of the bootcamp deals with the architecture of Outsystems environments. Makes sense, since a good architecture will help keep your development pace on par. As your environment grows, you might be able to group common subjects into domains. For example, we can group our sales related applications into a Commercial domain. In Lifetime you can group applications, and assign them to different teams. If you’re developing in a common core or foundation module, splitting your environment into parts will avoid impacting your whole factory. On the flipside, this type of architecture may lead to duplicate data and logic. When working with dependencies across domains, you can use "},{"type":"element","tagName":"a","properties":{"href":"https://success.outsystems.com/Documentation/11/Developing_an_Application/Reuse_and_Refactor/Use_Services_to_Expose_Functionality"},"children":[{"type":"text","value":"service actions"}]},{"type":"text","value":". This is similar to an server action, but uses an REST interface. This means you won’t have to refresh your dependencies when making a non-breaking change. I like that, but it can be a fallacy too. You won’t be alerted for outdated dependencies, so you will have to figure this out yourselves."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"An aggregate may be better than a reusable action"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"As with your factory architecture, it’s best to consider between reusability and performance on a screen level. When working with aggregates, Outsystems only retrieves the columns you’re using from the database. But when you’re assigning the full list as output of a server action, it will retrieve everything from the database."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"src":"https://res.cloudinary.com/dqwogyxqp/image/upload/v1648404129/Agregate_list_as_output_aff4a4f5b4.png","alt":"Agregate list as output.png"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So avoid using a server action to retrieve your data on a screen, since you rarely use everything. I’m using scaffolding often, so the extra work is neglectable."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Integrate using Integration Studio"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Service Studio offers a lot of functionality when consuming and exposing REST / SOAP API’s. But if not adequate, you can write your own integration plugin in .NET. Use cases might include custom cyphering and authentication. This is something that’s entirely new to me, but probably something I won’t need to do since the Forge is offering plugins to handle most use cases."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Avoid timeouts in timers"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Timers are a great way to handle batch processing. This is one of the biggest subjects at the Outsystems Traditional Professional exam, the exam that is following up on the bootcamp. So naturally we did get a few best practices for timers. I’m sharing one of the best patterns with you, "},{"type":"element","tagName":"a","properties":{"href":"https://www.outsystems.com/forums/discussion/60880/best-practices-timer-example-of-shown-code/"},"children":[{"type":"text","value":"the self-restarting timer"}]},{"type":"text","value":". This timer pattern sets a timeout and checks it within the loop. This timeout will often be 10 minutes, which is safely below the standard 20 minute timeout of timers. After exceeding the time limit, the time will restart itself using the WakeTimer node. You will need to implement functionality to keep track of the processed batches, but this way you’ll never run in a timeout."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"src":"https://res.cloudinary.com/dqwogyxqp/image/upload/v1648404130/Timer_best_practice_89b8c62c08.png","alt":"Timer best practice.png"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The coming two weeks I’ll be busy reading documentation for the "},{"type":"element","tagName":"a","properties":{"href":"https://www.outsystems.com/Certifications/"},"children":[{"type":"text","value":"Professional Traditional "}]},{"type":"element","tagName":"a","properties":{"href":"https://www.outsystems.com/Certifications/"},"children":[{"type":"text","value":"Web Developer exam"}]},{"type":"text","value":". This exam is said to be quite difficult, so hopefully I will have some time left to enjoy the beautiful spring weather in the Netherlands now!"}]}],"data":{"quirksMode":false}}},"content":"**The Outsystems Advanced bootcamp is a deep dive in the entire Outsystems ecosystem. In the past week I attended it at [Transfer Solutions](https://www.transfer-solutions.com/). It has been a great learning experience, ranging from small tips to best practices and more conceptual topics. I’m happy to share a few with you.**\n\n### Avoid monolithic architectures\nA great deal of the bootcamp deals with the architecture of Outsystems environments. Makes sense, since a good architecture will help keep your development pace on par. As your environment grows, you might be able to group common subjects into domains. For example, we can group our sales related applications into a Commercial domain. In Lifetime you can group applications, and assign them to different teams. If you’re developing in a common core or foundation module, splitting your environment into parts will avoid impacting your whole factory. On the flipside, this type of architecture may lead to duplicate data and logic. When working with dependencies across domains, you can use [service actions](https://success.outsystems.com/Documentation/11/Developing_an_Application/Reuse_and_Refactor/Use_Services_to_Expose_Functionality). This is similar to an server action, but uses an REST interface. This means you won’t have to refresh your dependencies when making a non-breaking change. I like that, but it can be a fallacy too. You won’t be alerted for outdated dependencies, so you will have to figure this out yourselves. \n\n### An aggregate may be better than a reusable action \nAs with your factory architecture, it’s best to consider between reusability and performance on a screen level. When working with aggregates, Outsystems only retrieves the columns you’re using from the database. But when you’re assigning the full list as output of a server action, it will retrieve everything from the database.\n\n![Agregate list as output.png](https://res.cloudinary.com/dqwogyxqp/image/upload/v1648404129/Agregate_list_as_output_aff4a4f5b4.png)\n  \nSo avoid using a server action to retrieve your data on a screen, since you rarely use everything. I’m using scaffolding often, so the extra work is neglectable.\n\n### Integrate using Integration Studio\nService Studio offers a lot of functionality when consuming and exposing REST / SOAP API’s. But if not adequate, you can write your own integration plugin in .NET. Use cases might include custom cyphering and authentication. This is something that’s entirely new to me, but probably something I won’t need to do since the Forge is offering plugins to handle most use cases.\n\n### Avoid timeouts in timers\nTimers are a great way to handle batch processing. This is one of the biggest subjects at the Outsystems Traditional Professional exam, the exam that is following up on the bootcamp. So naturally we did get a few best practices for timers. I’m sharing one of the best patterns with you, [the self-restarting timer](https://www.outsystems.com/forums/discussion/60880/best-practices-timer-example-of-shown-code/). This timer pattern sets a timeout and checks it within the loop. This timeout will often be 10 minutes, which is safely below the standard 20 minute timeout of timers. After exceeding the time limit, the time will restart itself using the WakeTimer node. You will need to implement functionality to keep track of the processed batches, but this way you’ll never run in a timeout. \n\n![Timer best practice.png](https://res.cloudinary.com/dqwogyxqp/image/upload/v1648404130/Timer_best_practice_89b8c62c08.png)\n \nThe coming two weeks I’ll be busy reading documentation for the [Professional Traditional ](https://www.outsystems.com/Certifications/)[Web Developer exam](https://www.outsystems.com/Certifications/). This exam is said to be quite difficult, so hopefully I will have some time left to enjoy the beautiful spring weather in the Netherlands now!"}},"SEO":{"keywords":"Outsystems, bootcamp, advanced bootcamp, course, exam, developer, course experience, best practices","metaDescription":"Sharing my experience of the Outsystems Advanced bootcamp","metaTitle":"Things I learned at the Outsystems Advanced bootcamp"}}},"pageContext":{"id":"72031594-3a7a-580d-b64d-d38622a305d5","slug":"things-i-learned-at-the-outsystems-advanced-bootcamp","__params":{"slug":"things-i-learned-at-the-outsystems-advanced-bootcamp"}}},"staticQueryHashes":["1343364089","2159283857","2389677789","3769587215","4020630752","584364458"],"slicesMap":{}}